# 레드블랙트리, B-Tree

생성일: 2020년 9월 22일 오후 11:58
최종수정일: 2020년 10월 21일 오전 1:48
태그: 강민창

## AVL트리

### -불균형 상태

- 일반적인 이진검색트리는 트리구조가 한쪽으로 치우쳐지는 경우가 있다. 이진검색트리의 검색성능은 높이에 의해 결정된다 → 한 쪽으로 치우치지않고 양쪽 균형을 맞추자!
- 하나의 노드를 기준으로 양쪽 서브트리의 높이 차이가 2 이상인 경우
- balance factor : bf ( 왼쪽서브트리높이 - 오른쪽 서브트리의 높이) 가 절댓값 2 이사이면 불균형
- 불균형 상태가 되면 리밸런싱 작업을 수행한다. ( 회전을 통해 )

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled.png)

- 여기에 15를 삽입해보자

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%201.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%201.png)

→→현재 14의 높이는 2 , NIL의 높이는 0이므로 불균형 상태가 되었다.

### -회전

- 회전의 종류에는  1번만 회전하는 LL, RR  2번 회전시키는 LR,RL이 존재한다.

### 1. LL회전

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%202.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%202.png)

-LL일때는 트리를 오른쪽으로 회전시켜주면 된다.

### 2. RR회전

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%203.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%203.png)

- RR일 때는 왼쪽으로 트리를 회전시키면 된다.

### 3. LR회전

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%204.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%204.png)

- 마지막 노드인 422값을 부모노드와 자리를 바꾸면 바로 LL형태가 된다 → LL회전한번더

### 4. RL회전

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%205.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%205.png)

- 마지막 노드인 422값을 부모노드와 자리를 바꾸면 바로 RR형태가 된다 → RR회전한번더

## AVL트리의 장단점

장점

검색, 삽입, 삭제 모두 O(log N)이며 항상 균형을 맞춘다.

---

단점

프로그래밍하기 어렵고 디버깅또한 어렵다. 검색, 삽입, 삭제가 빠르긴 하지만 균형을 맞추는데 필요한 연산이 많다.

# Red-Black Tree

- 이진탐색트리의 일종
- 균형잡힌 트리 : 높이가 O(logN)
- SEARCH, **INSERT**, **DELETE** 연산을 최악의 경우에도 O(logN)시간에 지원

C++의 map이 레드 블랙 트리 기반이다.

- **설명**

레드블랙트리는 이진탐색트리를 확장시켜서 균형기능을 추가시킨 트리입니다.

여기서 균형을 지키기 위한 조건이 5가지 있는데

이 조건을 만족하게 된다면 최악의 경우에도 가장 먼 거리가 가장 가까운 경로까지의 거리의 2배보다 항상 작게 됩니다.

따라서 균형잡힌 이진탐색트리가 되어 삽입, 삭제, 검색시에 최악의 경우에도 일정한 실행시간 O(log n)을 보장할 수 있습니다.

쓰이는 예로는, c++ stl의 map에서 red black트리가 쓰입니다.

balanced binary search tree 대표적인 예 : AVL트리, 레드블랙트리

레드 블랙 트리는 balanced binary search tree로

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%206.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%206.png)

이와 같은 모양이 나오지 않도록 "조건"을 걸어놈

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%207.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%207.png)

**레드블랙트리 조건**

1. 모든 노드는 레드, 블랙이다.
2. 루트노드의 색깔은 **검정**이다
3. 모든 리프노드는 **NIL**이고 **검정**이다.
4. 노드가 레드이면 그 노드의 자식은 반드시 **검정**이다. ( No Double Red )
5. 루트 노드에서 임의의 리프 노드에 이르는 경로에서 만나는 블랙 노드의 수는 모두 같다.

NIL 노드 : 자식 노드가 존재하지 않을 경우 NIL 노드라고 부르는 특수한 노드가 있다고 가정

왼쪽 자식과 오른쪽 자식이 없다고 하지않고 NIL노드를 자식으로 가지고 있다고 표현

루트의 부모도 NIL노드라고 가정

→ 실제 구현 시에 쓰이는 것이 아니고, 설명의 간편성을 위해 가상의 노드가 있다고 가정한 것

**삽입**

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%208.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%208.png)

1번 조건에 의해 루트노드의 색깔은 검정을 줬음

이제 값들을 삽입하는데, 삽입되는 노드의 색깔은 무조건 Red

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%209.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%209.png)

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2010.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2010.png)

이때 3번 조건을 위반함 **Double Red**

Double Red를 해결하는 전략 2가지가 있다.

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2011.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2011.png)

z가 삽입노드이고 w가 삼촌노드이다.

w가 검정일때 Restructuring, w가 빨강일때 Recoloring을 수행

- **Restructuring**
1. **나와 내 부모, 부모의 부모를 오름차순으로 정렬**
2. **무조건 가운데 있는 값을 부모로 만들고 나머지 둘을 자식으로 만든다.**
3. **올라간 가운데 있는 값을 검정으로 만들고 그 두자식들을 빨강으로 만든다.**

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2012.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2012.png)

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2013.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2013.png)

오름차순 정렬

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2014.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2014.png)

가운데 있는 값 부모로 만들고

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2015.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2015.png)

부모로 올라간 값은 검정, 나머지 자식은 빨강으로 만든다.

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2016.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2016.png)

원래 4의 자식이었던 2를 추가

Restructuring은 다른 서브트리에 영향을 끼치지 않기 때문에 **한번의 Restructuring**이면 끝남.

여기서 말하는 영향은 4번 조건인 **경로상의 검정 노드의 수**이다.

Double Red를 해결하기 전과 후의 검정 노드의 개수에 변화가 없기 때문에 다른 서브트리에 영향을 끼치지 않음 

Restructuring자체의 시간복잡도는 O(1)에 끝나지만, (순서결정시간 - 상수시간, 트리로 만드는시간 - 상수시간, 원래있던 노드들의 구조들을 바꿔주는 시간 - 상수시간)

Restructuring은 **어떤 노드를 insertion한 뒤 일어나므로** 총 수행시간은 **O(logn)**이에요. 지금 현재 노드가 들어갈 위치를 먼저 찾아야 하기 때문이죠.

- **Recoloring**
1. **현재 insert된 노드(z)의 부모와 그 형제(w)를 검정(Black)으로 하고 부모의 부모를 빨강으로 한다.**
2. **부모의 부모가 Root node가 아니었을 시 Double Red가 다시 발생 할 수 있다.**

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2017.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2017.png)

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2018.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2018.png)

여기서 4가 Root Node 였다면 1번 조건에 의해 검정이 된다.

하지만 어떤 큰 트리의 서브트리라고 한다면 4라는 key를 가진 노드의 부모가 또 빨강일 수 있다. 

레드블랙트리에 삽입(insertion)하는경우, Restructuring을 하든, Recoloring을 하든 O(logn)이 걸리게됩니다.

**삭제**

삭제시 주의할 점은 삭제로 인해 4번 조건인 루트에서 리프노드까지 경로의 검정 노드의 수가 모두 같다라는 조건이 위배되는 것이다.

- **기본 케이스**

m을 삭제한다고 했을 때

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2019.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2019.png)

1. m이 레드인 경우는 그냥 삭제
2. m이 블랙이고 자식이 레드인 경우는 삭제후 x의 노드를 블랙으로 바꾸면된다.

- **까다로운 경우**

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2020.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2020.png)

m과 x가 둘다 블랙인 경우 m을 삭제하면 블랙노드의 개수가 1개 줄기 때문에 

레드블랙트리 조건 4번에 위반하게 된다.

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2021.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2021.png)

Case 1-1

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2022.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2022.png)

p와 s의 색상을 맞바꾼다.

Case *-2

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2023.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2023.png)

 p를 중심으로 왼쪽으로 회전시키고, p와 s의 색상을 바꾼 다음 r의 색상을 레드에서 블랙으로 바꾼다

Case *-3

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2024.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2024.png)

s를 중심으로 오른쪽으로 회전시키고 l과 s의 색상을 맞바꾼다. Case *-2로 이동한다.

Case 2-1

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2025.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2025.png)

단순히 s의 색상을 블랙에서 레드로 바꾼다. 이제 s를 지나가는 경로에서도 블랙 노드가 하나 모자라게 되어 p를 지나가는 경로 전체에서 블랙 노드가 하나 모자라게 된다. 이것은 원래 x에 대해서 발생했던 문제와 똑같은 문제가 p에 대해서 발생했음을 뜻한다. 재귀적으로 이 문제를 해결한다.

Case 2-4

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2026.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2026.png)

p를 중심으로 왼쪽으로 회전시키고 p와 s의 색상을 맞바꾼다. l과 r을 경유하는 경로와 관련해서는 문제가 없다. 다만 문제가 발생한 x의 부모 노드의 색상이 블랙에서 레드로 바뀌었다. 이것은 Case 1에 해당하므로 Case 1로 이동한다.

[https://itstory.tk/entry/레드블랙-트리Red-black-tree](https://itstory.tk/entry/%EB%A0%88%EB%93%9C%EB%B8%94%EB%9E%99-%ED%8A%B8%EB%A6%ACRed-black-tree)

## Red-Black vs AVL

- AVL트리는 더욱 엄격한 균형을 이루고 있기 때문에 Red-Black 트리보다 더 빠른 조회를 제공
- Red-Black 트리는 상대적으로 느슨한 균형으로 인해 회전이 거의 이루어지지 않기 때문에 AVL트리보다 빠르게 삽입 및 제거 작업을 수행
- AVL트리는 각 노드에 대해 BF를 저장하므로 노드 당 int 저장이 필요Red-Black 트리는 노드당 1비트의 정보만 필요합니다. (플래그 반전만 시키면 됨)
- Red-Black 트리는 맵, C++의 멀티캐스트, Java treeMap 등 대부분의 언어 라이브러리에서 사용, AVL트리는 더 빠른 검색이 필요한 데이터베이스에서 사용

# B-Tree

B-Tree는 ORACLE과 같은 상용 DB에서 많이 사용하는 자료구조이며 외부검색에 유용하다고 알려짐, 이진 트리를 확장한 구조이다.

**특성**

- M차 B-Tree의 높이는 $log_{m/2}N$   즉, O(logN)의 성능
    - 한 노드에 M개의 자료, M+1개의 자식을 가질 수 있음
- 외부검색에 적합
    - 하나의 노드크기를 Disk I/O 단위의 크기로

하나의 노드가 다량의 데이터를 가질수 있기에 입출력시에 불러오는 블럭의 크기만큼 노드의 크기를 설정한다면 외부기억장치에 접근하는 횟수가 줄어들기 때문에 데이터를 빠르게 처리할 수 있다.

[https://www.cs.usfca.edu/~galles/visualization/BTree.html](https://www.cs.usfca.edu/~galles/visualization/BTree.html)

이진 트리의 한계 : 두 개의 자식밖에 가지질 못하고 자칫 균형이 맞지 않으면 검색 효율이 선형검색 급

편향 트리

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2027.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2027.png)

탐색, 삽입, 삭제

시간복잡도

O(h), h는 트리의 높이 → 최악의 경우 O(n)

편향 트리와 같은 밸런스가 맞지 않은 트리를 Unbalanced Tree라고 합니다.

반대로 완전 이진 트리와 같은 균형이 잡힌 트리를 Balanced Tree라고 하죠.

B-Tree는 이러한 방법 중 하나

**B-Tree 규칙**

- 노드의 자료수가 N이라면, 자식의 수는 N+1 이어야 한다.
- 각 노드의 자료는 정렬된 상태여야 한다.
- D노드의 왼쪽 서브트리는 D보다 작은 값들이고 D의 오른쪽 서브트리는 D보다 큰 값들이다.
- Root노드는 적어도 2개이상의 자식을 가져야 한다. (Root 혼자 있을때는 상관없음)
- Root노드를 제외한 모든 노드는 적어도 **M/2**개의 자료를 가지고 있어야 한다.
- 외부노드로 가는 경로의 길이는 모두 같다. ( balanced tree )
- 입력자료는 중복될 수 없다.

**삽입**

1. 자료는 항상 Leaf 노드에 추가된다.
2. 리프 노드의 선택은 ROOT 노드부터 시작해 하향식으로 탐색하며 결정한다.
3. 추가될 Leaf 노드에 여유가 있다면 그냥 삽입, 없다면(overflow) 분할

3차 B트리

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2028.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2028.png)

overflow 발생 시 노드의 중앙값을 부모로 올리고 두개의 노드로 분리

**삭제**

1-1. 리프노드에서 삭제시 바로 삭제

1-2. 중간노드에서 삭제시 자기보다 작은값의 자식노드와 자리를 바꾼후에 삭제

2. 그다음 노드의 자료수는 M/2 이상이어야 하는 원칙에 의해

삭제한 곳의 노드의 자료수가 M/2보다 작다면(underflow) 형제에게 빌리거나, 

부모하나와 형제와 결합

3. 재배열 필요시 2번 반복

1-1. Leaf Node인 경우

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2029.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2029.png)

1-2. Leaf Node에서 underflow발생시

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2030.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2030.png)

1을 삭제하면 underflow발생하기 때문에 1의 부모와 형제노드를 결합합니다. 이 과정을 조건이 root 로 올라가며 조건이 성립할때 까지 반복합니다.

2-1. Leaf Node가 아닌경우

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2031.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2031.png)

현재 18이 포함된 노드에는 자식이 존재합니다. 이때 18의 왼쪽 서브트리의 가장 큰 데이터와 18을 교체합니다. 그리고 Leef Node가 된 18을 삭제합니다. 그리고 이전 상황처럼 부모와 형제의 데이터를 결합하여 가져오는 과정을 반복합니다.

2-2 Leaf Node가 아닌 경우

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2032.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2032.png)

**B-Tree 장단점**

- 장점 : 노드의 삽입, 삭제후에도 균형 트리 유지로 균등한 응답속도 보장
시간 복잡도 : O(logN)
- 단점
    - 삽입과 삭제시 트리의 균형을 유지하기 위해 복잡한 연산이 필요
    - 메모리 낭비 
    → 노드가 많아질수록 전체 노드의 상당수가 비게되어 메모리 낭비가 발생
    ( 1/2일때 분열이 일어남, 2/3일때 분열이 되는 B*Tree 활용)
    - 순차탐색시에는 중위 순회로 비효율적임
    → B+ 트리 사용

# B+트리

- Index node들과 Data node로 구성
- Index node : 리프노드를 제외한 나머지 노드
    - Index set : index node 들의 모임 → 데이터의 빠른 접근을 위한 인덱스 역할
- Data node : 리프노드
    - sequence set : 리프노드의 모임 → 오름차순으로 정렬( 실제 데이터)
- Data node 는 연결리스트로 형성되어 있다.
- B트리의 순차접근에 대한 문제의 해결책으로 제시되었다.
- B트리와 다르게 삽입, 삭제연산이 리프노드에서만 이루어진다.
- 장점 : B+트리의 높이는 B트리보다 낮게 구성되므로 검색시간과 디스크 접근횟수가 줄어든다.
- 단점 : B Tree의 경우 best case에는 루트에서 끝날수 있지만, B+ Tree의 경우 무조껀 leaf노드까지 가야한다

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2033.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2033.png)

## B+트리의 삽입

- B트리와 유사하며, 리프에 오버플로우가 발생하면 두개의 노드로 분할하고 키 값들을 절반씩 분배해서 저장
    - 차수가 홀수일 때, 분할되서 부모로 올리는 값은 t-1번째 값   (t= [M/2](올림수)
    - 차수가 짝수일 때, 분할되서 부모로 올리는 값은 t번째 값
    - [https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)
    
    -차수가 3인 b+트리의 삽입
    
    (1,2) 삽입
    
    ![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2034.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2034.png)
    
    (3)삽입
    
    ![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2035.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2035.png)
    
    →  t -1 = (3/2)의 올림수 -1 = 1 이므로 1번째 값인 2가 부모 인덱스로 올라간다.
    
    (4)삽입
    
    ![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2036.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2036.png)
    
    →  t -1 = (3/2)의 올림수 -1 = 1 이므로 1번째 값인 3이 부모 인덱스로 올라간다.
    
    (5)삽입
    
    ![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2037.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2037.png)
    
    → t -1 = (3/2)의 올림수 -1 = 1 이므로 1번째 값인 4가 부모 인덱스로 올라간다.
    
    →그리고 부모 index node가 2 3 4이기때문에 
    
    →  t -1 = (3/2)의 올림수 -1 = 1 이므로 1번째 값인 3이 다시 부모인덱스로 간다.
    
    ## B+트리의 삭제
    
    - B+트리의 삭제연산은 리프노드에서만 실행되기 때문에 단순
    - 키 값을 삭제했을 때 리프노드가 underflow되지 않으면 키값을 삭제하고 index set에서도 삭제 후 적절한 key 값을 그 자리에 넣는다.
    - 키 값을 삭제 했을 대 리프노드가 underflow가 되면 형제노드에게 값을 빌리거나 병합한다
    
    ![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2038.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2038.png)
    

(2)삭제

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2039.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2039.png)

→underflow 없기 때문에 그냥 삭제

(1) 삭제

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2040.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2040.png)

→underflow 발생하면 형제노드 (3,4)확인 → 빌릴 수 있기 때문에 3을 1 이 있던 노드에 빌려준다.

→index노드에서 3을 삭제하고 4로 대체한다.

(3)삭제

![%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2041.png](%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5,%20B-Tree%207ad1dcf1b57c4a8883d952e8b7f0226b/Untitled%2041.png)

→underflow발생 → 형제노드(4)확인 → 못빌림 → 병합

# B트리 VS B+트리

### 공통점

1. 모든 leaf의 depth가 같다

2. 각 node에는 k/2 ~ k 개의 item이 들어있어야 한다.

3. add시 overflow가 발생하면 분할한다

4. delete 시 underflow가 발생하면 형제노드에서 빌리거나 합병 한다.

---

### 차이점

1. B-tree의 각 노드에서는 key 뿐만 아니라 data도 들어갈 수 있다

   -B+tree는 각 node에서는 key만 들어가야 한다. 그러므로 B+tree에서는 data는 오직 leaf에만 존재 

   한다.

2. B+tree는 B-tree와는 달리 add, delete가 leaf에서만 이루어진다.

3. B+ tree는 leaf node 끼리 linked list로 연결되어 있다.

# B* 트리

- B 트리는 구조를 유지하기 위해 추가적인 연산이 필요(재분배 , 합병 , 분열)
- B*트리는 이러한 문제를 보안하기 위해 나왔으며 B트리에서 최소 2/M의 키값을 가져야한다는 것은 2/3의 키값을 가져야한다고 변경함(메모리 효율)
- 리프를 제외한 모든 노드는 m개의 서브트리 이상을 가질 수 없다
- 루트와 리프를 제외한 모든 노드는 적어도 [(2m-2)/3]+1개의 서브트리를 갖는다.
- 루트는 리프가 아닌 이상 최소 2개, 적어도 2[(2m-2)/3]+1개의 서브트리를 갖는다.
- 모든 리프는 같은 레벨에 있다.
- 리프가 아닌 노드의 키 값의 수는 그 노드의 서브트리수보다 하나 적다
- 각 리프노드는 최소[ (2m-2)/3]개, 최대 m-1개의 키 값을 갖는다.